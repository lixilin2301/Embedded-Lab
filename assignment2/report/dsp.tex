\subsection{DSP}
The most important consideration for implementing any of the canny edge detection functions in the DSP is the use of floating point operations. The DSP found in the Beagleboard is the C64x+, which is highly parallelized with redundant functional units. These extra units allow for multiple multiply and add operations to be performed concurrently. However, they only support fixed-point operations by hardware. To be able to achieve a significant speedup, the gaussian smooth function was modified to use only these types of operations.

The first issue in modifying the gaussian smooth function was the kernel. It consists on 15 values that are used as filter taps for the smoothing. The make\_gaussian\_kernel function is in charge of generating them according to the sigma and window size values. Since these values are constant, the taps that are generated are always the same. This means that we can replace the function with an pre-generated array, which both facilitates the use of fixed-point arithmetic, and speeds up the overall application.

Now the filter taps need to be stored in fixed-point. The format chosen to store them was UQ16, which uses the whole 16 bits for the fractional part, with no sign or integer bits. This decision makes sense since all the taps are positive numbers between zero and one. The values were obtained by multiplying the floating-point taps by $2^{16}$ and converting to unsigned integers.

The use of the Q format for the taps simplified the modifications in the smooth gaussian function itself. The only change needed was to replace all "float" variables to unsigned 32 bit integers. The image being in 8-bit format, and the taps in 16-bit means that the DSP will do 16-bit operations and store them in 32-bits.  The speedup comes from the fact that the functional units in the DSP allow 4 of these operations to be done concurrently. Ideally, the result would be in UQ16 format too, however the function already implements a normalization, by dividing the dot product by the sum of the filter taps. The result of the division thus will be integer.

Once the gaussian smooth was implemented, another issue had to be solved: the memory usage. As it was originally coded, several intermediate arrays were created to store temporary values. With small images such as "tiger" and "square", this is not a problem, since the DSP had enough memory for these arrays. However, the image "klomp" is too big, and the memory allocations would fail. To improve memory usage, only the fraction of the image the DSP will actually use for its calculations is allocated. The result of the smooth is also now stored directly to the shared memory as it is being calculated, instead of using an temporary array. These improvements were enough to allow get rid of the memory allocation problem.