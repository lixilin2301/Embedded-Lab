\subsection{DSP}
The most important consideration for implementing \textit{gaussian\_smooth} function in DSP is the use of floating point operations. The DSP found in the Beagleboard is the C64x+, which is highly parallelized with redundant functional units. These extra units allow for multiple multiply and add operations to be performed concurrently. However, they only support fixed-point operations by hardware. To be able to achieve a significant speedup, the \textit{gaussian\_smooth} function was modified to use only these types of operations.

The first issue in modifying the \textit{gaussian\_smooth} function was the kernel. It consists on 15 values that are used as filter taps for the smoothing. The \textit{make\_gaussian\_kernel} function is in charge of generating them according to the sigma and window size values. Since these values are constant, the generated taps are always the same. This means that we can replace the function with an pre-generated array, which both facilitates the use of fixed-point arithmetic, and speeds up the overall application.

Now the filter taps need to be stored in fixed-point. The format chosen to store them is UQ16, which uses the whole 16 bits for the fractional part, with no sign or integer bits. This decision makes sense since all the taps are positive numbers between zero and one. The values are obtained by multiplying the floating-point taps by $2^{16}$ and converting to unsigned integers.

The use of the Q format for the taps simplified the modifications in the smooth gaussian function itself. The only change needed was to replace all \textit{float} variables to unsigned 32 bit integers. The image being in 8-bit format, and the taps in 16-bit means that the DSP will do 16-bit operations and store them in 32-bits.  The speedup comes from the fact that the functional units in the DSP allow four of these operations to be done concurrently. Ideally, the result would be in UQ16 format. However the function already implements a normalization, by dividing the dot product by the sum of the filter taps. Thus the result of the division will be integer as well.

Another issue that had to be solved is memory usage. As it was originally coded, several intermediate arrays were created to store temporary values. These buffers were also allocated large enough to fit the entire image. With small images such as \textit{tiger.pgm} and \textit{square.pgm}, memory usage is not a problem, since the DSP has enough memory for these arrays. However, the image \textit{klomp.pgm} is too big, and the memory allocations would fail due to memory limitations.

To improve memory usage, only the fraction of the image that is used by the DSP for its calculations is allocated. The result of the smoothed image is also stored directly to the shared memory as it is being calculated, instead of using a temporary array. These improvements were sufficient enough to get rid of the memory allocation problem and successfully run the application with larger images.

Writing directly into the shared memory did impose a speed penalty in later stages of the calculation, so to avoid this the GPP copies the results into another buffer after both the DSP and NEON have completed their blurring.

Other optimizing techniques were experimented with such as manual loop unrolling but showed no improvements in performance. Furthermore different flags specifically for the DSP compiler were tested, where only -O3 showed improvements. For more information on compiler flags see \hyperref[sec:flag]{Section \ref{sec:flag}}.